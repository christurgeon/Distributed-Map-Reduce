def printl[l:String] = print!(+$ (+$ "[" l) "]")

def or[b1:Bool b2:Bool out:/Bool] = 
	if b1 then
		out!true
	else if b2 then
		out!true
	else
		out!false

def remove[x:String current:Int size:Int builder:String res:/String] = 
	if (== current size) then
		res!builder
	else
		(val c = (string.nth x current)
		 if (or < (== c ';') (== c ',') (== c '.') (== c '"') (== c '\'')) then 
			remove![x (+ current 1) size builder res]
		 else 
			remove![x (+ current 1) size (+$ builder (char.toString c)) res])


def unpack[[a:Int b:String] res:/[]] = 
	(new s:^String
        (remove![b 0 (string.size (car (string.split " " b))) "" (rchan s)] 
	 | s?cleaned = printl![cleaned]
		))

def unpack_list[i:(List String) l:(List String) o:/(List String)] =
	if (null i) then
		o!l
	else
		o!(cons < (remove (car i) 0 (string.size (car i)) "" (rchan s)) (unpack_list (cdr i) l))

{- (remove![(car (string.split " " b)) 0 (string.size (car (string.split " " b))) "" (rchan s)] -}


def transform [list:(List [Int String]) res:/[]] = 
	if (null list) then res![]
	else
		(new b:^[]
		(unpack![(car list) (rchan b)] | b?_ = transform![(cdr list) res]))


run (
	val input = (cons > 
			[1 " ;his  I consider this here is"]
			[2 "  his majesty therefore history  "]
			[3 "hello    world i s how are you  "]
			nil)
	new x:^[]
	(transform![input (rchan x)] | x?_ = print!"Done")
)