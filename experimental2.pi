import "Std/List"


{- Supplied map, idk how to use it without hardcoding types FOR NOW -}
def map (#X #Y key:X value:Y):(List [X Y]) = (cons [key value] nil)
def reduce (#X #Y [key:X values:(List Y)]):(List [X (List Y)]) = (cons [key values] nil) 


type MapFunction = /[#X #Y X Y /(List [X Y])] 
type ReduceFunction = /[#X #Y [X (List Y)] /(List [X (List Y)])] 
type ResultsFeeder = /[#X #Y (List [X Y])]


{- ========================================================  HELPERS -}
def printl[x:(List Int) s:/[]] = 
	if (null x) then s![]
	else (printi!(car x) | printl![(cdr x) s])

def printup[#X #Y [x:X b:Y] f1:/[X /String] f2:/[Y /String]] = print!(+$ (+$ (f1 x) " ") (f2 b)) 

def printList[#X #Y list:(List [X Y]) f1:/[X /String] f2:/[Y /String] res:/[]] = 
	if (null list) then res![]
	else (printup![(car list) f1 f2] | printList![(cdr list) f1 f2 res])


def listToString[#Y l:(List Y) s:String p:/[Y /String] o:/String] =
	if (null l) then
		o!s
	else if (==$ s "") then
		o!(listToString (cdr l) (p (car l)) p)
	else
		o!(listToString (cdr l) (+$ (+$ s " ") (p (car l))) p)

def xyListToString[#X #Y [x:X temp:(List Y)] f1:/[X /String] f2:/[Y /String] o:/String] =
	o!(+$ < (f1 x) " [" (listToString temp "" f2) "]")

def printupGrouped[#X #Y [x:X b:(List Y)] f1:/[X /String] f2:/[Y /String]] = print!(xyListToString [x b] f1 f2) 

def printGroupedList [#X #Y list:(List [X (List Y)]) f1:/[X /String] f2:/[Y /String] res:/[]] = 
	if (null list) then res![]
	else (printupGrouped![(car list) f1 f2] | printGroupedList![(cdr list) f1 f2 res])

{- =========================================================================================-}




{- 
Takes in a tuple of key,value, a map function to apply, and a channel to send result
-}
def worker[#X #Y [a:X b:Y] map:MapFunction done:/[X Y]] = done!(car (map a b))



def groupMatch[#X #Y curKey:X [testKey:X l:(List Y)] e:/[X X /Bool] b:/Bool] = 
	b!(e curKey testKey)
def groupAppend[#X #Y [key:X lst:(List Y)] value:Y out:/[X (List Y)]] = 
	out![key (cons > value lst)]
def groupInsert[#X #Y [key:X value:Y] curList:(List [X (List Y)]) e:/[X X /Bool] outList:/(List [X (List Y)])] =
	if (null curList) then
		outList!(cons > [key (cons > value nil)] nil)
	else if (groupMatch key (car curList) e) then
		outList!(cons > (groupAppend (car curList) value) (cdr curList))
	else
		outList!(cons > (car curList) (groupInsert [key value] (cdr curList) e))
def groupList[#X #Y inList:(List [X Y]) curList:(List [X (List Y)]) e:/[X X /Bool] outList:/(List [X (List Y)])] =
	if (null inList) then
		outList!curList
	else
		outList!(groupList (cdr inList) (groupInsert (car inList) curList e) e)
def reduceAndCombine[#X #Y inList:(List [X Y]) xCompare:/[[X (List Y)] [X (List Y)] /Cmp] e:/[X X /Bool] outList:/(List [X (List Y)])] =
	outList!(list.sort (groupList inList nil e) xCompare true)


{-
Aggregator function to reas in `size` number of pairs from the `results` channel
The pairs come from worker function sending its result after applying map
-}
def resultsAggregator [#X #Y current:Int len:Int results:^[X Y] list:(List [X Y]) res:/(List [X Y])] = 
	if (<= current (- len 1)) then 
		(print!"result arrived" | 
		results?r = resultsAggregator![(+ current 1) len results (cons r list) res])
	else 
		res!list


{- 
Iterates through the input and summons workers to compute work unit.
iIt sends Sig when complete
-}
def iterateAndSummon [#X #Y input:(List [X Y]) map:MapFunction reschannel:/[X Y] done:/[]] =
	if (null input) then 
		done![]
	else (worker![(car input) map reschannel]
		 | iterateAndSummon![(cdr input) map reschannel done])
 


{-
IN: <reduce> function specified by user
IN: <input> list that is already sorted and grouped
OUT: <res> a channel to write out the list after reduce is applied on each element
-}
def reduceHandler [#X #Y reduce:ReduceFunction input:(List [X (List Y)]) list:(List [X (List Y)]) res:/(List [X (List Y)])] = 
	if (null input) then
		res!list	
	else 
		reduceHandler![reduce (cdr input) (cons (reduce (car input)) list) res]

{-
mapReduce driver method
-}
def mapReduce [#X #Y map:MapFunction reduce:ReduceFunction compare:/[[X (List Y)] [X (List Y)] /Cmp] e:/[X X /Bool] f1:/[X /String] f2:/[Y /String] input:(List [X Y])] = 
	if (null input) then 
		print!"NULL list!"
	else (new d1:^[] 
		new reschannel:^[X Y]
		new finalresult:^(List [X Y])
		val length = (size input)
		val l = (cons > nil)
		(print!(+$ "Starting: len(input) = " (int.toString length)) 
		| iterateAndSummon![input map (rchan reschannel) (rchan d1)] 
		| resultsAggregator![0 len reschannel l (rchan finalresult)] 
		| finalresult?r = 
			(new reduced_list:^(List [X Y])
			 new d3:^[]
			 val grouped_list = (reduceAndCombine r compare e)
                               	(printGroupedList![grouped_list f1 f2 (rchan d1)] 
                               	| d1?_ = print!"Grouping completed..." 
                               	| reduceHandler![reduce grouped_list (rchan reduced_list)]
				| reduced_list?r2 = (printList![r2 f1 f2 (rchan d3)] | d3?_ = print!"Reduce completed") 
					))))



def cmp_2d[[v1:Int l1:(List Int)] [v2:Int l2:(List Int)] o:/Cmp] = o!(int.cmp v1 v2)

run mapReduce![map reduce cmp_2d == int.toString int.toString (cons > [1 2] [2 4] [6 8] [6 7] [1 3] nil)]
