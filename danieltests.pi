{- run print2nd![#Int lst int.toString] -}

def print2nd[#X l:(List X) p:/[X /String]] =
	if (null l) then print!"Null list"
	else if (null (cdr l)) then print!"Null tail"
	else print!(p (car (cdr l)))


{- run printNth![#Int lst -1 int.toString] -}
def printNth[#X l:(List X) n:Int p:/[X /String]] =
	if (null l) then print!"Index out of bounds"
	else if (>= n 1) then printNth![#X (cdr l) (- n 1) p]
	else print!(p (car l))

{- run printi!(car (cdr (cdr lst))) -}
{- run printi!(getNthInt lst 3) -}
def getNthInt(l:(List Int) n:Int):Int =
	if (null l) then -99999
	else if (>= n 1) then (getNthInt (cdr l) (- n 1))
	else (car l)

{-
run (new res:^[Int Int String]
     val default = 999999
     (getNth![default lst 0 (rchan res)]
     | res?x = printFromGet![x int.toString]))
-}
def getNth [#X default:X l:(List X) n:Int res:/[X Int String]] =
	if (null l) then 
		res![default 0 "outofbounds"]
	else if (>= n 1) then 
		getNth![default (cdr l) (- n 1) res]
	else 
		res![(car l) 1 "success"]
def printFromGet[#X [v:X s:Int t:String] p:/[X /String]] =
	if (== s 0) then print!t
	else print!(p v)

{-
	OLD, function changed
run print!(+$ (+$ "yeet" " ") "yote")
run listToString![lst "" int.toString]
run listToString![(list.sort lst int.cmp (== 0 0)) "" int.toString]

val lst2 = (list.sort lst int.cmp (== 0 0))
run listToString![lst2 "" int.toString]

run print!(cmp.toString (int.cmp 0 0))
-}
def listToString[#X l:(List X) s:String p:/[X /String] o:/String] =
	if (null l) then
		o!s
	else
		o!(listToString (cdr l) (+$ (+$ s " ") (p (car l))) p)

{-
run listToString![(list.sort lst int.cmp (== 0 0)) "" int.toString]
val lst2d_sorted = (list.sort lst_2d cmp_2d (== 0 0))
run listToString![lst2d_sorted "" print_Int_Str]
-}
def print_Int_Str[[v:Int s:String] o:/String] =
	o!s
def cmp_2d[[v1:Int s1:String] [v2:Int s2:String] o:/Cmp] =
	o!(int.cmp v1 v2)

{- run print!(testXY 0 false) -}
def testXY[#X #Y x:X y:Y o:/String] = o!"Yay"

{- type GroupedList = (List [X (List Y)]) -}

{- type XEquals = /[#X X X /Bool] -}
def groupMatch[#X #Y curKey:X [testKey:X l:(List Y)] e:/[X X /Bool] b:/Bool] = 
	b!(e curKey testKey)
def groupAppend[#X #Y [key:X lst:(List Y)] value:Y out:/[X (List Y)]] = 
	out![key (cons > value lst)]
def groupInsert[#X #Y [key:X value:Y] curList:(List [X (List Y)]) e:/[X X /Bool] outList:/(List [X (List Y)])] =
	if (null curList) then
		outList!(cons > [key (cons > value nil)] nil)
	else if (groupMatch key (car curList) e) then
		outList!(cons > (groupAppend (car curList) value) (cdr curList))
	else
		outList!(cons > (car curList) (groupInsert [key value] (cdr curList) e))
def groupList[#X #Y inList:(List [X Y]) curList:(List [X (List Y)]) e:/[X X /Bool] outList:/(List [X (List Y)])] =
	if (null inList) then
		outList!curList
	else
		outList!(groupList (cdr inList) (groupInsert (car inList) curList e) e)

val lst = (cons > 0 8 1 2 5 3 nil)
val lst_2d = (cons > [0 "zero"] [8 "eight"] [1 "one"] [2 "two"] [5 "five"] [3 "three"] nil)

def xyListToString[[x:Int temp:(List Int)] o:/String] =
	o!(+$ < (int.toString x) " [" (listToString temp "" int.toString) "] ")

val pre_grp_lst = (cons > [2 1] [1 5] [2 3] [3 4] [1 2] nil)
val post_grp_lst = (groupList pre_grp_lst nil ==)

{- NOTE: output is interleaved -}
{- NOTE: errors ignore indentation -}
{- NOTE: find facts on X by "run print!(X)" -}
{- sort = /[#X (List X) /[X X /Cmp] Bool /(List X)] -}

run print!"working"
run print!(listToString post_grp_lst "" xyListToString)
