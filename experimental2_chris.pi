import "Std/List"
import "Std/Float"

type K1 = Int
type V1 = String 
type K2 = String
type V2 = Int
type K3 = String 
type V3 = (List Int)

type MapFunction = /[K1 V1 /(List [K2 V2])] 
type ReduceFunction = /[[K2 (List V2)] /[K3 V3]] 
type ResultsFeeder = /[(List [K1 V1])]

{- ===================================================================
   ===================================================================
   			    PROBLEM 2 
			    
THE COMPARE FUNCTION SHOULD DUMP EVERYTHING INTO THE SAME BUCKET
def compare(k1 k2) = true
-}

type K2 = Int 
type V2 = (List Int)
type K3 = String
type V3 = String

{- current< ["Characters" 0] ["Characters per Word" 0] ["Words" 0] ["Words per Line" 0] > -}
def helper[l:(List V2) size:Int charcount:Int wordcount:Int out:/(List [K3 V3])] = 
	if (null l) then
	(val words_per_line = (float.div (float.fromInt wordcount) (float.fromInt size))
 	 val chars_per_word = (float.div (float.fromInt charcount) (float.fromInt wordcount))	
	 out!(cons > 
			["Characters" (int.toString charcount)] 
			["Characters per Word" (float.toString chars_per_word)] 
			["Words" (int.toString wordcount)] 
			["Words per Line" (float.toString words_per_line)] 
			nil))
	else 
		(val new_size = (+ size 1)
		 val sublist = (car l)
                 val new_charcount = (+ charcount (car sublist))
		 val new_wordcount = (+ wordcount (car (cdr sublist)))
		 helper![(cdr l) new_size new_charcount new_wordcount out]
		)
	

def reduce[[k:K2 v:(List V2)] out:/(List [K3 V3])] = 
	(new c:^(List [K3 V3])
	(helper![v 0 0 0 (rchan c)] | c?result = out!result))
	

def tryPrint[[a:K3 b:V3]] = print!(+$ > a " " b)
def printlst[l:(List [K3 V3]) res:/[]] = 
	if (null l) then 
		res![]
	else (tryPrint![(car l)] | printlst![(cdr l) res])
 
{-
run (
	val list = (cons > [1 (cons > (cons > 10 30 nil) (cons > 70 80 nil) (cons > 1 2 nil) nil)] nil)
	new c:^(List [K3 V3])
	new d:^[]
	(reduce![(car list) (rchan c)] | c?out = printlst![out (rchan d)])
)
-}



{- ========================================================  HELPERS -}
def printl[x:(List Int) s:/[]] = 
	if (null x) then s![]
	else (printi!(car x) | printl![(cdr x) s])

def printup[[x:K1 b:V1] f1:/[K1 /String] f2:/[V1 /String]] = print!(+$ (+$ (f1 x) " ") (f2 b)) 

def printList [list:(List [K1 V1]) f1:/[K1 /String] f2:/[V1 /String] res:/[]] = 
	if (null list) then 
		res![]
	else (printup![(car list) f1 f2] | printList![(cdr list) f1 f2 res])


def listToString[l:(List V2) s:String p:/[V2 /String] o:/String] =
	if (null l) then
		o!s
	else if (==$ s "") then
		o!(listToString (cdr l) (p (car l)) p)
	else
		o!(listToString (cdr l) (+$ (+$ s " ") (p (car l))) p)

def xyListToString[[x:K2 temp:(List V2)] f1:/[K2 /String] f2:/[V2 /String] o:/String] =
	o!(+$ < (f1 x) " [" (listToString temp "" f2) "]")

def printupGrouped[[x:K2 b:(List V2)] f1:/[K2 /String] f2:/[V2 /String]] = print!(xyListToString [x b] f1 f2) 

def printGroupedList [list:(List [K2 (List V2)]) f1:/[K2 /String] f2:/[V2 /String] res:/[]] = 
	if (null list) then res![]
	else (printupGrouped![(car list) f1 f2] | printGroupedList![(cdr list) f1 f2 res])

{- =========================================================================================-}




{- 
Takes in a tuple of key,value, a map function to apply, and a channel to send result
-}
def worker[[a:K1 b:V1] map:MapFunction done:/(List [K2 V2])] = done!(map a b)


def groupMatch[curKey:K2 [testKey:K2 l:(List V2)] e:/[K2 K2 /Bool] b:/Bool] = 
	b!(e curKey testKey)
def groupAppend[[key:K2 lst:(List V2)] value:V2 out:/[K2 (List V2)]] = 
	out![key (cons > value lst)]
def groupInsert[[key:K2 value:V2] curList:(List [K2 (List V2)]) e:/[K2 K2 /Bool] outList:/(List [K2 (List V2)])] =
	if (null curList) then
		outList!(cons > [key (cons > value nil)] nil)
	else if (groupMatch key (car curList) e) then
		outList!(cons > (groupAppend (car curList) value) (cdr curList))
	else
		outList!(cons > (car curList) (groupInsert [key value] (cdr curList) e))

def groupList[inList:(List [K2 V2]) curList:(List [K2 (List V2)]) e:/[K2 K2 /Bool] outList:/(List [K2 (List V2)])] =
	if (null inList) then
		outList!curList
	else
		outList!(groupList (cdr inList) (groupInsert (car inList) curList e) e)

def reduceAndCombine[inList:(List [K2 V2]) xCompare:/[[K2 (List V2)] [K2 (List V2)] /Cmp] e:/[K2 K2 /Bool] outList:/(List [K2 (List V2)])] =
	outList!(list.sort (groupList inList nil e) xCompare true)


{-
Aggregator function to reas in `size` number of pairs from the `results` channel
The pairs come from worker function sending its result after applying map
-}
def resultsAggregator [current:Int len:Int results:^(List [K2 V2]) list:(List [K2 V2]) res:/(List [K2 V2])] = 
	if (<= current (- len 1)) then 
		(print!"result arrived" | 
		results?r = resultsAggregator![(+ current 1) len results (cons (car r) list) res]) {- we don't actually want the (car r) but we'll take it for now -}
	else 
		res!list


{- 
Iterates through the input and summons workers to compute work unit.
iIt sends Sig when complete
-}
def iterateAndSummon [input:(List [K1 V1]) map:MapFunction reschannel:/(List [K2 V2]) done:/[]] =
	if (null input) then 
		done![]
	else (worker![(car input) map reschannel]
		 | iterateAndSummon![(cdr input) map reschannel done])
 

{-
IN reduce reduce function specified by the user
IN input list that is already sorted and grouped
IN currlst running list of reduced groups
OUT res channel to send the list through when reduce is applied on all memebers of input
-}
def reduceHandler [reduce:ReduceFunction input:(List [K2 (List V2)]) currlst:(List [K3 V3]) res:/(List [K3 V3])] = 
	if (null input) then 
		res!currlst
	else 
		reduceHandler![reduce (cdr input) (cons (reduce (car input)) currlst) res]


{-
IN map map function
IN reduce reduce function
IN compare> compare function
IN e custom comparator to help sort keys
IN f1 print helper
IN f2 print helper
IN input input specified by user
-}
def mapReduce [map:MapFunction reduce:ReduceFunction compare:/[[K2 (List V2)] [K2 (List V2)] /Cmp] e:/[K2 K2 /Bool] f1:/[K2 /String] f2:/[V2 /String] input:(List [K1 V1])] = 
	if (null input) then 
		print!"NULL list!"
	else (new d1:^[] 
		new reschannel:^(List [K2 V2])
		new finalresult:^(List [K2 V2])
		val len = (list.size input)
		(print!(+$ "Starting: len(input) = " (int.toString len)) 
			| iterateAndSummon![input map (rchan reschannel) (rchan d1)] 
			| resultsAggregator![0 len reschannel (cons > nil) (rchan finalresult)] 
			| finalresult?r = 
				(new d2:^[]
				 new reduced_list:^(List [K3 V3])
				 val grouped_list = (reduceAndCombine r compare e)
					(printGroupedList![grouped_list f1 f2 (rchan d1)]
					| d1?_ = print!"Grouping complete..."
					| reduceHandler![reduce grouped_list (cons > nil) (rchan reduced_list)]
					| reduced_list?r2 = printlst![r2 (rchan d2)]
						))))


{-
def compare[[v1:K2 l1:(List V2)] [v2:K2 l2:(List V2)] o:/Cmp] = o!(int.cmp v1 v2)
-}

def p1_remove[x:String current:Int size:Int builder:String res:/String] = 
	if (== current size) then
		res!builder
	else (
		val c = (string.nth x current)
		if (|| < (== c ',') (== c '.') (== c '!') (== c '?') (== c ';')  (== c ':') (== c '"') (== c '\'')) then 
			res!(p1_remove x (+ current 1) size builder)
		else 
			res!(p1_remove x (+ current 1) size (+$ builder (char.toString c)))
	)


def p1_clean_strings[i:(List String) l:(List String) o:/(List String)] =
	if (null i) then
		o!l
	else
		o!(cons > (p1_remove (car i) 0 (string.size (car i)) "") (p1_clean_strings (cdr i) l))

def p1_filter_strings [inLst:(List String) line:Int o:/(List [String Int])] =
	if (null inLst) then
		o!nil
	else if (string.in p1_GLOBALSEARCHSTRING (car inLst)) then
		o!(cons > [(car inLst) line] (p1_filter_strings (cdr inLst) line))
	else
		o!(p1_filter_strings (cdr inLst) line)



def map [linenum:K1 line:V1 out:/(List [K2 V2])] = 
	out!(p2_aggregate_stats)

def p1_map [i:Int s:String o:/(List [String Int])] =
	o!(p1_filter_strings (p1_clean_strings (string.split " " s) nil) i)

def p1_compare[[ls:String li:(List Int)] [rs:String ri:(List Int)] o:/Cmp] = 
	o!(int.cmp (string.size ls) (string.size rs))

	

run mapReduce![p1_map reduce p1_compare == int.toString int.toString input]







