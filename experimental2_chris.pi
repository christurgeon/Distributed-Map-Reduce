import "Std/List"
import "Std/Float"

{- ===================================================================
   ===================================================================
   			    PROBLEM 2 
-}

type K1 = Int 
type V1 = String
type K2 = Int 
type V2 = (List Int)
type K3 = Int
type V3 = (List [String String])

type MapFunction = /[K1 V1 /(List [K2 V2])] 
type ReduceFunction = /[[K2 (List V2)] /[K3 V3]] 
type ResultsFeeder = /[(List [K1 V1])]




{- ========================================================  HELPERS -}
def intListToStringHelper[x:(List Int) curr:String s:/String] = 
	if (null x) then s!curr
	else intListToStringHelper![(cdr x) (+$ < curr " " (int.toString (car x))) s]
def intListToString[x:(List Int) s:/String] = s!(intListToStringHelper x "")

def printup[[x:K1 b:V1] f1:/[K1 /String] f2:/[V1 /String]] = print!(+$ (+$ (f1 x) " ") (f2 b)) 

def printList [list:(List [K1 V1]) f1:/[K1 /String] f2:/[V1 /String] res:/[]] = 
	if (null list) then 
		res![]
	else (printup![(car list) f1 f2] | printList![(cdr list) f1 f2 res])


def listToString[l:(List V2) s:String p:/[V2 /String] o:/String] =
	if (null l) then
		o!s
	else if (==$ s "") then
		o!(listToString (cdr l) (p (car l)) p)
	else
		o!(listToString (cdr l) (+$ (+$ s " ") (p (car l))) p)

def xyListToString[[x:K2 temp:(List V2)] f1:/[K2 /String] f2:/[V2 /String] o:/String] =
	o!(+$ < (f1 x) " [" (listToString temp "" f2) "]")

def printupGrouped[[x:K2 b:(List V2)] f1:/[K2 /String] f2:/[V2 /String]] = print!(xyListToString [x b] f1 f2) 

def printGroupedList [list:(List [K2 (List V2)]) f1:/[K2 /String] f2:/[V2 /String] res:/[]] = 
	if (null list) then res![]
	else (printupGrouped![(car list) f1 f2] | printGroupedList![(cdr list) f1 f2 res])


def tryPrint[[a:String b:String]] = print!(+$ > "\"" a "\"" " " b)
def printlst[[a:K3 b:V3] res:/[]] = 
	if (null b) then res![]
	else (tryPrint![(car b)] | printlst![[a (cdr b)] res])
{- =========================================================================================-}




{- 
Takes in a tuple of key,value, a map function to apply, and a channel to send result
-}
def worker[[a:K1 b:V1] map:MapFunction done:/(List [K2 V2])] = done!(map a b)


def groupMatch[curKey:K2 [testKey:K2 l:(List V2)] e:/[K2 K2 /Bool] b:/Bool] = 
	b!(e curKey testKey)
def groupAppend[[key:K2 lst:(List V2)] value:V2 out:/[K2 (List V2)]] = 
	out![key (cons > value lst)]
def groupInsert[[key:K2 value:V2] curList:(List [K2 (List V2)]) e:/[K2 K2 /Bool] outList:/(List [K2 (List V2)])] =
	if (null curList) then
		outList!(cons > [key (cons > value nil)] nil)
	else if (groupMatch key (car curList) e) then
		outList!(cons > (groupAppend (car curList) value) (cdr curList))
	else
		outList!(cons > (car curList) (groupInsert [key value] (cdr curList) e))

def groupList[inList:(List [K2 V2]) curList:(List [K2 (List V2)]) e:/[K2 K2 /Bool] outList:/(List [K2 (List V2)])] =
	if (null inList) then
		outList!curList
	else
		outList!(groupList (cdr inList) (groupInsert (car inList) curList e) e)

def reduceAndCombine[inList:(List [K2 V2]) xCompare:/[[K2 (List V2)] [K2 (List V2)] /Cmp] e:/[K2 K2 /Bool] outList:/(List [K2 (List V2)])] =
	outList!(list.sort (groupList inList nil e) xCompare true)


{-
Aggregator function to reas in `size` number of pairs from the `results` channel
The pairs come from worker function sending its result after applying map
-}
def resultsAggregator [current:Int len:Int results:^(List [K2 V2]) list:(List [K2 V2]) res:/(List [K2 V2])] = 
	if (<= current (- len 1)) then 
		(print!"result arrived" | 
		results?r = resultsAggregator![(+ current 1) len results (cons (car r) list) res]) {- we don't actually want the (car r) but we'll take it for now -}
	else 
		res!list


{- 
Iterates through the input and summons workers to compute work unit.
iIt sends Sig when complete
-}
def iterateAndSummon [input:(List [K1 V1]) map:MapFunction reschannel:/(List [K2 V2]) done:/[]] =
	if (null input) then 
		done![]
	else (worker![(car input) map reschannel]
		 | iterateAndSummon![(cdr input) map reschannel done])
 

{-
IN reduce reduce function specified by the user
IN input list that is already sorted and grouped
IN currlst running list of reduced groups
OUT res channel to send the list through when reduce is applied on all memebers of input
-}
def reduceHandler [reduce:ReduceFunction input:(List [K2 (List V2)]) currlst:(List [K3 V3]) res:/(List [K3 V3])] = 
	if (null input) then 
		res!currlst
	else 
		reduceHandler![reduce (cdr input) (cons (reduce (car input)) currlst) res]


{-
IN map map function
IN reduce reduce function
IN compare> compare function
IN e custom comparator to help sort keys
IN f1 print helper
IN f2 print helper
IN input input specified by user
-}
def mapReduce [map:MapFunction reduce:ReduceFunction compare:/[[K2 (List V2)] [K2 (List V2)] /Cmp] e:/[K2 K2 /Bool] f1:/[K2 /String] f2:/[V2 /String] input:(List [K1 V1])] = 
	if (null input) then 
		print!"NULL list!"
	else (new d1:^[] 
		new reschannel:^(List [K2 V2])
		new finalresult:^(List [K2 V2])
		val len = (list.size input)
		(print!(+$ "Starting: len(input) = " (int.toString len)) 
			| iterateAndSummon![input map (rchan reschannel) (rchan d1)] 
			| resultsAggregator![0 len reschannel (cons > nil) (rchan finalresult)] 
			| finalresult?r = 
				(new d2:^[]
				 new reduced_list:^(List [K3 V3])
				 val grouped_list = (reduceAndCombine r compare e)
					(printGroupedList![grouped_list f1 f2 (rchan d1)]
					| d1?_ = print!"Grouping complete..."
					| reduceHandler![reduce grouped_list (cons > nil) (rchan reduced_list)]
					| reduced_list?r2 = ( printlst![(car r2) (rchan d2)] | print!"Reduce complete..." )
						))))




{- current< ["Characters" 0] ["Characters per Word" 0] ["Words" 0] ["Words per Line" 0] > -}
def helper[l:(List V2) size:Int charcount:Int wordcount:Int out:/[K3 V3]] = 
	if (null l) then
	(val words_per_line = (float.div (float.fromInt wordcount) (float.fromInt size))
 	 val chars_per_word = (float.div (float.fromInt charcount) (float.fromInt wordcount))	
	 out![0 (cons > 
			["Characters" (int.toString charcount)] 
			["Characters per Word" (float.toString chars_per_word)] 
			["Words" (int.toString wordcount)] 
			["Words per Line" (float.toString words_per_line)] 
			nil)])
	else 
		(val new_size = (+ size 1)
		 val sublist = (car l)
                 val new_charcount = (+ charcount (car (cdr sublist)))
		 val new_wordcount = (+ wordcount (car sublist))
		 helper![(cdr l) new_size new_charcount new_wordcount out]
		)
	

def p2_reduce[[k:K2 v:(List V2)] out:/[K3 V3]] = 
	(new c:^[K3 V3]
	(helper![v 0 0 0 (rchan c)] | c?result = out!result))
	

def p1_remove[x:V1 current:Int size:Int builder:V1 res:/V1] = 
	if (== current size) then
		res!builder
	else (
		val c = (string.nth x current)
		if (|| < (== c ',') (== c '.') (== c '!') (== c '?') (== c ';')  (== c ':') (== c '"') (== c '\'')) then 
			res!(p1_remove x (+ current 1) size builder)
		else 
			res!(p1_remove x (+ current 1) size (+$ builder (char.toString c)))
	)

def p1_clean_strings[i:(List V1) l:(List V1) o:/(List V1)] =
	if (null i) then 
		o!l 
	else 
		( print!(car i)
			| p1_clean_strings![(cdr i) (cons (p1_remove (car i) 0 (string.size (car i)) "") l) o]
)

def p2_stats [in:(List V1) x:K1 [numwords:K2 numchars:K2] o:/(List [K2 V2])] = 
	if (null in) then 
		o!(cons [x (cons > numwords numchars nil)] nil)
	else 
		p2_stats![(cdr in) x [(+ numwords 1) (+ numchars (string.size (car in)))] o]
def p2_aggregate_stats [x:K1 line:V1 o:/(List [K2 V2])] =
	o!(p2_stats (p1_clean_strings (string.split " " line) nil) x [0 0])
def p2_map [linenum:K1 line:V1 o:/(List [K2 V2])] = 
	o!(p2_aggregate_stats 0 line)	
def p2_compare [[ls:Int li:(List (List Int))] [rs:Int ri:(List (List Int))] o:/Cmp] = 
	o!(int.cmp ls rs)
	
val input = (cons >
	[1 "hi th st"]
	[2 "my nm is"]
	[3 ";bruh ,hello"]
	nil)
 
run mapReduce![p2_map p2_reduce p2_compare == int.toString intListToString input]







