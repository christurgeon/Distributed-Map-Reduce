import "Std/List"

type K1 = Int
type V1 = Int 
type K2 = Int
type V2 = Int
type K3 = Int 
type V3 = (List Int)

def map (key:K1 value:V1):(List [K2 V2]) = (cons [key value] nil)
def reduce ([key:K2 values:(List V2)]):[K3 V3] = [key values] 

type MapFunction = /[K1 V1 /(List [K2 V2])] 
type ReduceFunction = /[[K2 (List V2)] /[K3 V3]] 
type ResultsFeeder = /[(List [K1 V1])]


{- ========================================================  HELPERS -}
def printl[x:(List Int) s:/[]] = 
	if (null x) then s![]
	else (printi!(car x) | printl![(cdr x) s])

def printup[[x:K1 b:V1] f1:/[K1 /String] f2:/[V1 /String]] = print!(+$ (+$ (f1 x) " ") (f2 b)) 

def printList [list:(List [K1 V1]) f1:/[K1 /String] f2:/[V1 /String] res:/[]] = 
	if (null list) then 
		res![]
	else (printup![(car list) f1 f2] | printList![(cdr list) f1 f2 res])


def listToString[l:(List V2) s:String p:/[V2 /String] o:/String] =
	if (null l) then
		o!s
	else if (==$ s "") then
		o!(listToString (cdr l) (p (car l)) p)
	else
		o!(listToString (cdr l) (+$ (+$ s " ") (p (car l))) p)

def xyListToString[[x:K2 temp:(List V2)] f1:/[K2 /String] f2:/[V2 /String] o:/String] =
	o!(+$ < (f1 x) " [" (listToString temp "" f2) "]")

def printupGrouped[[x:K2 b:(List V2)] f1:/[K2 /String] f2:/[V2 /String]] = print!(xyListToString [x b] f1 f2) 

def printGroupedList [list:(List [K2 (List V2)]) f1:/[K2 /String] f2:/[V2 /String] res:/[]] = 
	if (null list) then res![]
	else (printupGrouped![(car list) f1 f2] | printGroupedList![(cdr list) f1 f2 res])

{- =========================================================================================-}




{- 
Takes in a tuple of key,value, a map function to apply, and a channel to send result
-}
def worker[[a:K1 b:V1] map:MapFunction done:/(List [K2 V2])] = done!(map a b)


def groupMatch[curKey:K2 [testKey:K2 l:(List V2)] e:/[K2 K2 /Bool] b:/Bool] = 
	b!(e curKey testKey)
def groupAppend[[key:K2 lst:(List V2)] value:V2 out:/[K2 (List V2)]] = 
	out![key (cons > value lst)]
def groupInsert[[key:K2 value:V2] curList:(List [K2 (List V2)]) e:/[K2 K2 /Bool] outList:/(List [K2 (List V2)])] =
	if (null curList) then
		outList!(cons > [key (cons > value nil)] nil)
	else if (groupMatch key (car curList) e) then
		outList!(cons > (groupAppend (car curList) value) (cdr curList))
	else
		outList!(cons > (car curList) (groupInsert [key value] (cdr curList) e))

def groupList[inList:(List [K2 V2]) curList:(List [K2 (List V2)]) e:/[K2 K2 /Bool] outList:/(List [K2 (List V2)])] =
	if (null inList) then
		outList!curList
	else
		outList!(groupList (cdr inList) (groupInsert (car inList) curList e) e)

def reduceAndCombine[inList:(List [K2 V2]) xCompare:/[[K2 (List V2)] [K2 (List V2)] /Cmp] e:/[K2 K2 /Bool] outList:/(List [K2 (List V2)])] =
	outList!(list.sort (groupList inList nil e) xCompare true)


{-
Aggregator function to reas in `size` number of pairs from the `results` channel
The pairs come from worker function sending its result after applying map
-}
def resultsAggregator [current:Int len:Int results:^(List [K2 V2]) list:(List [K2 V2]) res:/(List [K2 V2])] = 
	if (<= current (- len 1)) then 
		(print!"result arrived" | 
		results?r = resultsAggregator![(+ current 1) len results (cons (car r) list) res]) {- we don't actually want the (car r) but we'll take it for now -}
	else 
		res!list


{- 
Iterates through the input and summons workers to compute work unit.
iIt sends Sig when complete
-}
def iterateAndSummon [input:(List [K1 V1]) map:MapFunction reschannel:/(List [K2 V2]) done:/[]] =
	if (null input) then 
		done![]
	else (worker![(car input) map reschannel]
		 | iterateAndSummon![(cdr input) map reschannel done])
 

{-
IN <reduce> reduce function specified by the user
IN <input> list that is already sorted and grouped
IN <currlst> running list of reduced groups
OUT <res> channel to send the list through when reduce is applied on all memebers of input
-}
def reduceHandler [reduce:ReduceFunction input:(List [K2 (List V2)]) currlst:(List [K3 V3]) res:/(List [K3 V3])] = 
	if (null input) then 
		res!currlst
	else 
		reduceHandler![reduce (cdr input) (cons (reduce (car input)) currlst) res]


{-
IN <map> map function
IN <reduce> reduce function
IN <compare> compare function
IN <e> custom comparator to help sort keys
IN <f1> print helper
IN <f2> print helper
IN <input> input specified by user
-}
def mapReduce [map:MapFunction reduce:ReduceFunction compare:/[[K1 (List V1)] [K1 (List V1)] /Cmp] e:/[K2 K2 /Bool] f1:/[K2 /String] f2:/[V2 /String] input:(List [K1 V1])] = 
	if (null input) then 
		print!"NULL list!"
	else (new d1:^[] 
		new reschannel:^(List [K2 V2])
		new finalresult:^(List [K2 V2])
		val len = (list.size input)
		(print!(+$ "Starting: len(input) = " (int.toString len)) 
			| iterateAndSummon![input map (rchan reschannel) (rchan d1)] 
			| resultsAggregator![0 len reschannel (cons > nil) (rchan finalresult)] 
			| finalresult?r = 
				(new d2:^[]
				 new reduced_list:^(List [K3 V3])
				 val grouped_list = (reduceAndCombine r compare e)
					(printGroupedList![grouped_list f1 f2 (rchan d1)]
					| d1?_ = print!"Grouping complete..."
					| reduceHandler![reduce grouped_list (cons > nil) (rchan reduced_list)]
					| reduced_list?r2 = print!"Reduce complete..." 
						))))



def compare[[v1:K2 l1:(List V2)] [v2:K2 l2:(List V2)] o:/Cmp] = o!(int.cmp v1 v2)

run mapReduce![map reduce compare == int.toString int.toString (cons > [1 2] [2 4] [6 8] [6 7] [1 3] nil)]
