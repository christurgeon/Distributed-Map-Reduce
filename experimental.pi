import "Std/List"

{- Supplied map, idk how to use it without hardcoding types FOR NOW -}
def map (#X key:Int value:X):(List [Int X]) = (cons [key value] nil)

{-
def map [#X key:Int value:X] = (cons [key value] nil)
-}

{- 
def compare (key1 val1) = (<= key1 val1)
def reduce (key values) = (cons [key values] nil) 
-} 

type MapFunction = /[#X Int X /(List [Int X])]

{- Working FOR loop implementation -}
def for [i:Int j:Int p:/[Int Sig] c:/[]] = 
	if (<= i j) then 
		(new d:^[]
		(p![i (rchan d)]
		| d?[] = for![(+ i 1) j p c]))
	else c![]


def worker[#X work:[a=Int b=X] map:MapFunction done:/[]] = 
	(val t = work
	 new br:^Bool (==![0 0 (rchan br)] 
		      | br?b = if b then (done![] | printi!t.a) {- | (map a b))-}
					else done![]))


{- Experimental loop to summon the workers -}
def iterateAndSummon [#X input:(List [a=Int b=X]) map:MapFunction done:/[]] =
	if (null input) then 
		done![]
	else (new d:^[]
		{- Send to worker actor then recurse -}
		(worker![(car input) map (rchan d)]
		| d?[] = iterateAndSummon![(cdr input) map done]))
 

def mapReduce [#X map:MapFunction input:(List [a=Int b=X])] = 
	if (null input) then print!"NULL list!"
	else (new d:^[] 
		(for![1 5 \[x:Int c:Sig] = (printi!x | c![]) (rchan d)] {- FOR LOOP FROM CLASS, JUST FOR EXAMPLE-}
		| d?[] = ( print!"For Loop Done"
			 | iterateAndSummon![input map (rchan d)]       {- NOW TRYING TO CALL THIS GUY -}
			 | d?[] = print!"Finished..."
				)))       


run mapReduce![map (cons > [1 2] [2 4] nil)]
