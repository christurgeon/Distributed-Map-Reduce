import "Std/List"

{- Supplied map, idk how to use it without hardcoding types FOR NOW -}
def map (#X key:Int value:X):(List [Int X]) = (cons [key value] nil)
def reduce (#X key:Int values:(List X)):(List [Int (List X)]) = (cons [key values] nil) 


type MapFunction = /[#X Int X /(List [Int X])] 
type ReduceFunction = /[#X Int (List X) /(List [Int (List X)])] 
type ResultsFeeder = /[#X (List [Int X])]


def printl[x:(List Int) s:/[]] = 
	if (null x) then s![]
	else (printi!(car x) | printl![(cdr x) s])

def printup[#X [x:Int b:X] f:/[X /String]] = 
	(printi!x | print!(f b)) 


def printList [#X list:(List [Int X]) f:/[X /String] res:/[]] = 
	if (null list) then 
		res![]
	else (printup![(car list) f] | printList![(cdr list) f res])
	

def append(#X element:(List [Int X]) list:(List (List [Int X]))):(List (List [Int X])) = (cons element list) 


def unwrap (#X [a:Int b:(List X)] f:ReduceFunction):(List [Int (List X)]) = (f a b) 

{- 
Takes in a tuple of key,value, a map function to apply, and a channel to send result
-}
def worker[#X [a:Int b:X] map:MapFunction done:/[Int X]] = 
	done!(car (map a b))

{-
Call reduce with each key and its associated lists of values in the sorted order.
Combine the output lists of all reduce calls into a single list.
Send the results through `result` return channel.
-}
def reduceAndCombine [#X input:(List [Int (List X)]) reduced:(List (List [Int (List X)])) reducer:ReduceFunction result:/(List (List [Int (List X)]))] = 
	if (null input) then 
		result!reduced
	else	(val r = (unwrap (car input) reducer)                 
		 reduceAndCombine![(cdr input) (cons r reduced) reducer result])


{-
Aggregator function to reas in `size` number of pairs from the `results` channel
The pairs come from worker function sending its result after applying map
-}
def resultsAggregator [#X current:Int len:Int results:^[Int X] list:(List [Int X]) res:/(List [Int X])] = 
	if (<= current (- len 1)) then 
		(print!"result arrived" | 
		results?r = resultsAggregator![(+ current 1) len results (cons r list) res])
	else 
		res!list


{- 
Iterates through the input and summons workers to compute work unit.
iIt sends Sig when complete
-}
def iterateAndSummon [#X input:(List [Int X]) map:MapFunction reschannel:/[Int X] done:/[]] =
	if (null input) then 
		done![]
	else (worker![(car input) map reschannel]
	     | iterateAndSummon![(cdr input) map reschannel done])
 


{- 
Accepts a list and a starting counter value and loops through the list 
and increasing counter by that amoung
-} 
def size [#X input:(List [Int X]) counter:Int total:/Int] =
	if (null input) then
		total!counter
	else size![(cdr input) (+ counter 1) total]


{-
mapReduce driver method
-}
def mapReduce [#X map:MapFunction reduce:ReduceFunction input:(List [Int X])] = 
	if (null input) then 
		print!"NULL list!"
	else (new d:^[] 
              new reschannel:^[Int X]
	      new finalresult:^(List [Int X])
	      new length:^Int
	      val l = (cons > nil) 
              (size![input 0 (rchan length)] | length?len = 
			( print!"Starting..."
	                | printi!len 
			| iterateAndSummon![input map (rchan reschannel) (rchan d)] 
			| resultsAggregator![0 len reschannel l (rchan finalresult)] 
                        | finalresult?r = (printList![r int.toString (rchan d)] | d?_ = print!"done")
				)))


run mapReduce![map reduce (cons > [1 2] [2 4] [6 8] nil)]
