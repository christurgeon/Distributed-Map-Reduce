import "Std/List"


{- Supplied map, idk how to use it without hardcoding types FOR NOW -}
def map (#X #Y key:X value:Y):(List [X Y]) = (cons [key value] nil)
def reduce (#X #Y key:X values:(List Y)):(List [X (List Y)]) = (cons [key values] nil) 


type MapFunction = /[#X #Y X Y /(List [X Y])] 
type ReduceFunction = /[#X #Y X (List Y) /(List [X (List Y)])] 
type ResultsFeeder = /[#X #Y (List [X Y])]



{- ========================================================  HELPERS -}
def printl[x:(List Int) s:/[]] = 
	if (null x) then s![]
	else (printi!(car x) | printl![(cdr x) s])

def printup[#X #Y [x:X b:Y] f1:/[X /String] f2:/[Y /String]] = print!(+$ (+$ (f1 x) " ") (f2 b)) 

def printList [#X #Y list:(List [X Y]) f1:/[X /String] f2:/[Y /String] res:/[]] = 
	if (null list) then 
		res![]
	else (printup![(car list) f1 f2] | printList![(cdr list) f1 f2 res])


def listToString[#Y l:(List Y) s:String p:/[Y /String] o:/String] =
	if (null l) then
		o!s
	else if (==$ s "") then
		o!(listToString (cdr l) (p (car l)) p)
	else
		o!(listToString (cdr l) (+$ (+$ s " ") (p (car l))) p)

def xyListToString[#X #Y [x:X temp:(List Y)] f1:/[X /String] f2:/[Y /String] o:/String] =
	o!(+$ < (f1 x) " [" (listToString temp "" f2) "]")

def printupGrouped[#X #Y [x:X b:(List Y)] f1:/[X /String] f2:/[Y /String]] = print!(xyListToString [x b] f1 f2) 

def printGroupedList [#X #Y list:(List [X (List Y)]) f1:/[X /String] f2:/[Y /String] res:/[]] = 
	if (null list) then res![]
	else (printupGrouped![(car list) f1 f2] | printGroupedList![(cdr list) f1 f2 res])

{- =========================================================================================-}




{- 
Takes in a tuple of key,value, a map function to apply, and a channel to send result
-}
def worker[#X #Y [a:X b:Y] map:MapFunction done:/[X Y]] = 
	done!(car (map a b))



def groupMatch[#X #Y curKey:X [testKey:X l:(List Y)] e:/[X X /Bool] b:/Bool] = 
	b!(e curKey testKey)
def groupAppend[#X #Y [key:X lst:(List Y)] value:Y out:/[X (List Y)]] = 
	out![key (cons > value lst)]
def groupInsert[#X #Y [key:X value:Y] curList:(List [X (List Y)]) e:/[X X /Bool] outList:/(List [X (List Y)])] =
	if (null curList) then
		outList!(cons > [key (cons > value nil)] nil)
	else if (groupMatch key (car curList) e) then
		outList!(cons > (groupAppend (car curList) value) (cdr curList))
	else
		outList!(cons > (car curList) (groupInsert [key value] (cdr curList) e))
def groupList[#X #Y inList:(List [X Y]) curList:(List [X (List Y)]) e:/[X X /Bool] outList:/(List [X (List Y)])] =
	if (null inList) then
		outList!curList
	else
		outList!(groupList (cdr inList) (groupInsert (car inList) curList e) e)
def reduceAndCombine[#X #Y inList:(List [X Y]) xCompare:/[[X (List Y)] [X (List Y)] /Cmp] e:/[X X /Bool] outList:/(List [X (List Y)])] =
	outList!(list.sort (groupList inList nil e) xCompare true)


{-
Aggregator function to reas in `size` number of pairs from the `results` channel
The pairs come from worker function sending its result after applying map
-}
def resultsAggregator [#X #Y current:Int len:Int results:^[X Y] list:(List [X Y]) res:/(List [X Y])] = 
	if (<= current (- len 1)) then 
		(print!"result arrived" | 
		results?r = resultsAggregator![(+ current 1) len results (cons r list) res])
	else 
		res!list


{- 
Iterates through the input and summons workers to compute work unit.
iIt sends Sig when complete
-}
def iterateAndSummon [#X #Y input:(List [X Y]) map:MapFunction reschannel:/[X Y] done:/[]] =
	if (null input) then 
		done![]
	else (worker![(car input) map reschannel]
		 | iterateAndSummon![(cdr input) map reschannel done])
 


{- 
Accepts a list and a starting counter value and loops through the list 
and increasing counter by that amoung
-} 
def size [#X #Y input:(List [X Y]) counter:Int total:/Int] =
	if (null input) then
		total!counter
	else size![(cdr input) (+ counter 1) total]


{-
mapReduce driver method
-}
def mapReduce [#X #Y map:MapFunction reduce:ReduceFunction xCompare:/[[X (List Y)] [X (List Y)] /Cmp] e:/[X X /Bool] f1:/[X /String] f2:/[Y /String] input:(List [X Y])] = 
	if (null input) then 
		print!"NULL list!"
	else (new d:^[] 
		new reschannel:^[X Y]
		new finalresult:^(List [X Y])
		new length:^Int
		val l = (cons > nil)
		(size![input 0 (rchan length)] | length?len = 
			( print!(+$ "Starting: len(input) = " (int.toString len)) 
			| iterateAndSummon![input map (rchan reschannel) (rchan d)] 
			| resultsAggregator![0 len reschannel l (rchan finalresult)] 
			| finalresult?r = (printGroupedList![(reduceAndCombine r xCompare e) f1 f2 (rchan d)] | d?_ = print!"done") 
				)))



def cmp_2d[[v1:Int l1:(List Int)] [v2:Int l2:(List Int)] o:/Cmp] = o!(int.cmp v1 v2)

run mapReduce![map reduce cmp_2d == int.toString int.toString (cons > [1 2] [2 4] [6 8] [6 7] [1 3] nil)]

{-
val pre_grp_lst = (cons > [2 1] [1 5] [2 3] [3 4] [1 2] nil)
val post_grp_lst = (groupList pre_grp_lst nil ==)

val final_lst = (reduceAndCombine pre_grp_lst cmp_2d ==)
run print!(listToString post_grp_lst "" xyListToString)
run print!(listToString final_lst "" xyListToString)
-}
