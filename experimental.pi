import "Std/List"

{- Supplied map, idk how to use it without hardcoding types FOR NOW -}
def map (#X key:Int value:X):(List [Int X]) = (cons [key value] nil)

{- 
def compare (key1 val1) = (<= key1 val1)
def reduce (key values) = (cons [key values] nil) 
-} 

type MapFunction = /[#X Int X /(List [Int X])]

{- Working FOR loop implementation -}
def for [i:Int j:Int p:/[Int Sig] c:/[]] = 
	if (<= i j) then 
		(new d:^[]
		(p![i (rchan d)]
		| d?[] = for![(+ i 1) j p c]))
	else c![]


{- 
Takes in a tuple of key,value, a map function to apply, and a channel to send result
-}
def worker[#X [a:Int b:X] map:MapFunction done:/(List [Int X])] = 
	done!(map a b)



{-
Aggregator function to reas in `size` number of pairs from the `results` channel
The pairs come from worker function sending its result after applying map
-}
def resultsAggregator [#X current:Int size:Int results:^[(List [Int X])] list:(List (List [Int X])) res:/[(List (List [Int X]))]] = 
	if (<= current (- size 1)) then 
		results?r = resultsAggregator![(+ 1 current) size results (cons r list) res]
	else 
		res![list]



{- 
Iterates through the input and summons workers to compute work unit.
It sends Sig when complete
-}
def iterateAndSummon [#X input:(List [Int X]) map:MapFunction done:/[]] =
	if (null input) then 
		done![]
	else (new d:^(List [Int X])
		{- Send to worker actor then recurse -}
		(worker![(car input) map (rchan d)]
		| d?result = iterateAndSummon![(cdr input) map done]))
 


{- 
Accepts a list and a starting counter value and loops through the list 
and increasing counter by that amoung
-} 
def size [#X input:(List [Int X]) counter:Int total:/Int] =
	if (null input) then
		total!counter
	else size![(car input) (+ counter 1) total]


{-
mapReduce driver method
-}
def mapReduce [#X map:MapFunction input:(List [Int X])] = 
	if (null input) then 
		print!"NULL list!"
	else (new d:^[] 
              new length:^Int
              new reschannel:^[#X (List [Int X])]
	      new finalresult:^[#X (List [Int X])]
	      (size![input 1 (rchan length)]
              | length?size = 
			( print!"Starting..."
                        | printi!size
			| iterateAndSummon![input map reschannel (rchan d)]   
			| resultsAggregator![1 size reschannel (cons > nil) finalresult]
			| d?[] = print!"iterateAndSummon() complete"
                        | finalresult?r = 
				print!"Finished..."
					)))       

run mapReduce![map (cons > [1 2] [2 4] [6 8] nil)]
